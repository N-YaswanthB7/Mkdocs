{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the Design Documentation site for the Curiosity Card system.</p> <p>Use the navigation on the left to browse detailed documents about:</p>"},{"location":"#properties","title":"Properties:","text":"<ul> <li>Get Curiosity Eeprom Card ID</li> <li>Getting Card Details From EEPROM</li> </ul>"},{"location":"Get_curiosityEepromCardID/","title":"Get Curiosity EEPROM Card ID","text":"<p>\ud83c\udff7\ufe0f Title: Card ID Retrieval for Curiosity Card \ud83c\udd94 Story ID: CUR-132 \ud83d\udc64 Author: Narasapuram Yaswanth \ud83d\uddd3\ufe0f Date: 17-06-2025</p>"},{"location":"Get_curiosityEepromCardID/#1-overview","title":"\ud83d\udd0d 1. Overview","text":"<ul> <li>This feature enables retrieval of the unique Card ID from the Curiosity card. This ID is used by the Galaxy application to fetch corresponding card metadata.</li> </ul>"},{"location":"Get_curiosityEepromCardID/#2-scope","title":"\ud83d\udce6 2. Scope","text":"<p>This feature focuses exclusively on the retrieval of the Card ID for a Curiosity Card. While the Card ID is expected to be stored in the EEPROM, in the current Erlang implementation, it is fetched from an environment variable. The Card ID acts as a critical identifier that enables Galaxy applications to link and retrieve relevant card metadata.</p> <p>\u2705 In Scope</p> <ul> <li>Reading the 2-byte Card ID from EEPROM using the I2C protocol (In Brief).</li> <li>Defining and exposing a new Erlang property <code>curiosityEepromCardID</code> that reads the Card ID from environment variables.</li> <li>Handling valid inputs structured as <code>[?INDEX_TUPLE, ?INTERFACE_TUPLE]</code> and returning appropriate output format.</li> <li>Implementing input validation and error responses for incorrect or malformed requests.</li> </ul>"},{"location":"Get_curiosityEepromCardID/#3-inputs-and-outputs","title":"\ud83d\udd01 3. Inputs and Outputs","text":"<p>\ud83d\udce5 Inputs:</p> <ul> <li> <p>Input to get_curiosityEepromCardID property is list of two tuples: <code>[ ?INDEX_TUPLE, ?INTERFACE_TUPLE ]</code></p> <ol> <li> <p>?INDEX_TUPLE -&gt;</p> <ul> <li><code>{index,[ {node,_Node_number}, {rack, _Rack}, {subrack, _Subrack}, {slot, _Slot} ]}</code></li> </ul> </li> <li> <p>?INTERFACE_TUPLE -&gt;</p> <ul> <li><code>{ interface, List_of_interfaces }</code></li> </ul> </li> </ol> </li> </ul> <p>\ud83d\udce4 Outputs:</p> <ul> <li>Card ID is 2-byte hexadecimal.</li> <li>On success the output looks like: <code>[ { success }, [ { Property_name , Card_id_from_eeprom } ] ]</code></li> </ul> <p>Property_name -&gt; curiosityEepromCardID and Card_id_from_eeprom -&gt; 0x5C</p>"},{"location":"Get_curiosityEepromCardID/#4-design-approach","title":"\ud83d\udee0\ufe0f 4. Design Approach","text":"<p>To enable the Erlang node to access card-related information during system initialization, the card ID is first retrieved from EEPROM at the C layer and made available to the Galaxy application through environment variables present in the <code>vim.args</code> file.</p> <p>Details:</p> <ul> <li>Added function: <code>get_curiosityEepromCardID()</code> in <code>curiosity_mif.erl</code> module.</li> <li>This function calls <code>?COMMON_FUNCTION_LIB:read_environment_variable_value(card_id_from_eeprom)</code> to fetch the Card ID from the environment variables using the <code>card_id_from_eeprom</code> atom.</li> <li>The returned value is stored in the <code>Card_id_from_eeprom</code> variable and is used for further validation or processing logic as needed by the application.</li> </ul> <p>Note: For more details on how card data is read from EEPROM, see \ud83d\udc49 Retrieving Card Details from EEPROM</p>"},{"location":"Get_curiosityEepromCardID/#5-sequence-flow-for-get_curiosityeepromcardid1","title":"\ud83d\udd04 5. Sequence Flow for get_curiosityEepromCardId/1","text":"<ol> <li> <p>Input:   The function is called with a single argument which is a tuple of the form  </p> <p><code>[ ?INDEX_TUPLE, ?INTERFACE_TUPLE ]</code></p> </li> <li> <p>Property Assignment:   The variable <code>Property_name</code> is assigned the atom <code>curiosityEepromCardId</code>.</p> </li> <li> <p>Pattern Matching on <code>?INTERFACE_TUPLE</code>: </p> <ul> <li>The function matches the value of <code>?INTERFACE_TUPLE</code>:</li> <li>If it matches <code>{ interface, [0] }</code>:<ul> <li>Calls <code>?COMMON_FUNCTION_LIB:read_environment_variable_value(card_id_from_eeprom)</code> to get <code>Card_id_from_eeprom</code>.</li> </ul> </li> <li>Otherwise, if it matches <code>{ interface, _any }</code> (anything other than <code>[0]</code>):<ul> <li>Logs an \"Invalid Argument\" error and returns an error tuple.</li> </ul> </li> </ul> </li> <li> <p>Check if <code>Card_id_from_eeprom</code> is an integer:</p> <ul> <li>If <code>Card_id_from_eeprom</code> is an integer:<ul> <li>Return <code>[ { success }, [ { curiosityEepromCardId, Card_id_from_eeprom } ] ]</code></li> </ul> </li> <li>If not an integer:<ul> <li>Prints an error indicating the environment variable is not an integer and returns, <p><code>[ { error, card_id_from_environment_variable_is_not_an_integer_value }, [ ] ]</code></p> </li> </ul> </li> </ul> </li> <li> <p>If the initial argument does not match the expected tuple structure: </p> <ul> <li>prints an \"Invalid Argument\" error and returns, <p><code>[ { error, invalid_argument }, [ ] ]</code></p> </li> </ul> </li> </ol>"},{"location":"Get_curiosityEepromCardID/#6-error-handling","title":"\ud83d\udea8 6. Error Handling","text":"<ul> <li>Failure Scenarios in Erlang:<ul> <li>If invalid arguments are passed to <code>get_card_details_from_eeprom()</code>, an error message is printed and the function returns: <p>[ { error, invalid_argument }, [ ] ]</p> </li> <li>If <code>?INTERFACE_TUPLE</code> is not <code>{interface, [0]}</code>, an error message is printed and the function returns: <p>[ { error, invalid_argument }, [ ] ]</p> </li> <li>If the return value from <code>?COMMON_FUNCTION_LIB:read_environment_variable_value(card_id_from_eeprom)</code> is not an integer, an error message is printed and the function returns: <p>[ { error, card_id_from_environment_variable_is_not_an_integer_value }, [ ] ]</p> </li> </ul> </li> </ul>"},{"location":"Get_curiosityEepromCardID/#7-configuration-or-constants","title":"\u2699\ufe0f 7. Configuration or Constants","text":"<ol> <li><code>-define CURIOSITY_EEPROM_CARD_ID 92</code></li> <li><code>-define CURIOSITY_I2C_BUS_0 0</code></li> <li><code>-define CURIOSITY_I2C_BUS_1 1</code></li> <li><code>-define COMMON_FUNCTION_LIB galaxy_common_function</code></li> </ol>"},{"location":"Get_curiosityEepromCardID/#8-impacted-files","title":"\ud83d\udcc2 8. Impacted Files","text":"<ul> <li>Modified:<ul> <li>start_uo.c</li> </ul> </li> <li>Added:<ul> <li>This property is added in curiosity_mif.erl</li> </ul> </li> </ul>"},{"location":"Get_curiosityEepromCardID/#9-unit-test-summary","title":"\ud83e\uddea 9. Unit Test Summary","text":""},{"location":"Get_curiosityEepromCardID/#acceptance-test-cases","title":"Acceptance Test Cases:","text":"<ul> <li><code>CUR-1</code> Retrieve EEPROM Card ID with valid interface number.</li> <li><code>CUR-2</code> Retrieve EEPROM Card ID with valid interface number.</li> </ul>"},{"location":"Get_curiosityEepromCardID/#10-references","title":"\ud83d\udd17 10. References","text":"<ul> <li>Jira Story CUR-132\u200b</li> <li>Commit: a1b2c3d - card_id: add support for ID retrieval\u200b</li> <li>I2C Protocol Ref Sheet\u200b </li> </ul>"},{"location":"Getting%20Card%20Details%20From%20EEPROM/","title":"Retrieving EEPROM Card Details","text":"<p>\ud83c\udff7\ufe0f Title: Card Details Retrieval for Curiosity from EEPROM \ud83d\udc64 Author: Narasapuram Yaswanth \ud83d\uddd3\ufe0f Date: 19-06-2025</p>"},{"location":"Getting%20Card%20Details%20From%20EEPROM/#1-overview","title":"\ud83d\udd0d 1. Overview","text":"<ul> <li>This feature enables retrieval of the Card details from EEPROM for Curiosity card. The retrieved information will be used by the Galaxy application.</li> </ul>"},{"location":"Getting%20Card%20Details%20From%20EEPROM/#2-scope","title":"\ud83d\udce6 2. Scope","text":"<p>This feature focuses on the retrieval of card data stored in the EEPROM of a Curiosity Card. The retrieved information is essential for Galaxy applications to link and access relevant metadata associated with the card.</p>"},{"location":"Getting%20Card%20Details%20From%20EEPROM/#3-inputs-and-outputs","title":"\ud83d\udd01 3. Inputs and Outputs","text":"<p>\ud83d\udce5 Inputs:</p> <ul> <li>Input to get_card_details_from_eeprom() function is :<code>&amp;card_details_from_eeprom_return</code> which is a structure variable<ol> <li>struct card_details_from_eeprom     {         unsigned short  card_id;         char            card_name[55];         char            part_code[65];         char            internal_hardware_version[8];         char            internal_software_version[8];         char            external_hardware_version[8];         char            external_software_version[8];         unsigned int    card_uid;         char            mac_compatible_48_bit_uid[20];         unsigned char   m24aa256uid_device_address;     };</li> </ol> </li> </ul> <p>\ud83d\udce4 Outputs:</p> <ul> <li> <p>The function get_card_details_from_eeprom() returns a status code:</p> <ul> <li> <p><code>SUCCESS</code> (typically defined as 0) if all EEPROM reads and data formatting operations succeed.</p> </li> <li> <p><code>FAILURE</code> (typically defined as -1) if any error occurs during EEPROM probing, reading, or data formatting.</p> </li> </ul> </li> </ul>"},{"location":"Getting%20Card%20Details%20From%20EEPROM/#4-design-approach","title":"\ud83d\udee0\ufe0f 4. Design Approach","text":"<p>The <code>start_up.c</code> file retrieves card-related information from EEPROM using the <code>get_card_details_from_eeprom()</code> function, which reads multiple fields from an EEPROM device connected via I2C_BUS_0, and stores the information in the <code>vm.args</code> file.</p> <p>Details:</p> <ul> <li>It first probes the EEPROM device address using a shell command (<code>i2cdetect</code>) executed via <code>system()</code>. The exit code stored in <code>eeprom_probe_status</code>. The detected address is then stored in <code>command_error_code</code> using <code>WEXITSTATUS(eeprom_probe_status)</code>.</li> <li>Several blocks of memory are read from the EEPROM using <code>read_multiple_bytes_from_m24aa256uid()</code>:<ul> <li>Card ID (2 bytes)</li> <li>Card Name (54 bytes)</li> <li>Part Code (64 bytes)</li> <li>Card Version (8 bytes)</li> </ul> </li> <li>Versions are formatted into string representations of <code>major.minor</code> versions for internal/external hardware/software.</li> <li>The function reads a 4-byte UID and a 6-byte 48-bit unique identification number (EUI-48) for MAC compatibility.</li> <li>EUI-48 is validated to be non-zero to confirm a valid EEPROM.</li> <li>The MAC address is formatted into a standard colon-separated hex string.</li> <li>Any failure during I2C read or formatting causes the function to return <code>FAILURE</code>.</li> </ul>"},{"location":"Getting%20Card%20Details%20From%20EEPROM/#5-step-wise-flow","title":"\ud83d\udd04 5. Step-wise Flow","text":"<p>System Initialization Flow: 1. Triggered from system initialization. 2. Executes <code>start_up.c</code>. 3. Insdie <code>start_up.c</code>, it calls <code>get_card_details_from_eeprom()</code>.</p> <p>Inside <code>get_card_details_from_eeprom()</code> Function: 4. Execute shell command to probe EEPROM I2C device address. 5. Validate device address. 6. Then call to <code>read_multiple_bytes_from_m24aa256uid()</code> to:     - Read card ID bytes from EEPROM.     - Read card name bytes from EEPROM.     - Read part code bytes from EEPROM.     - Read card version bytes from EEPROM. 7. Format version numbers into strings. 8. Then call to <code>read_uid_from_m24aa256uid()</code> to:      - Read card UID bytes from EEPROM. 9. Then call to <code>read_eui48_from_m24aa256uid()</code> to:      - Read 48-bit EUI-48 bytes from EEPROM. 10. Validate EUI-48 is non-zero. 11. Format MAC-compatible 48-bit UID string. 12. Return <code>SUCCESS</code> if all operations succeed; otherwise <code>FAILURE</code>.</p>"},{"location":"Getting%20Card%20Details%20From%20EEPROM/#6-error-handling","title":"\ud83d\udea8 6. Error Handling","text":"<ul> <li>If the EEPROM probe command fails or returns an invalid address, it prints an error message to the console and return <code>FAILURE</code>.</li> <li>If any of the EEPROM reads fail, the function returns <code>FAILURE</code>.</li> <li>If formatting the version strings or MAC string fails (e.g., <code>sprintf</code> returns an error), it prints an error message to the console and return <code>FAILURE</code>.</li> <li>If the EUI-48 read value is all zeros, indicating invalid data, prints an error message to the console and return <code>FAILURE</code>.</li> </ul> <p>These errors ensure the system does not operate on invalid or incomplete card data.</p>"},{"location":"Getting%20Card%20Details%20From%20EEPROM/#7-configuration-or-constants","title":"\u2699\ufe0f 7. Configuration or Constants","text":"<p>EEPROM memory address constants:</p> <ul> <li><code>card_id_start_memory_address = 0x0040</code></li> <li><code>card_name_start_memory_address = 0x0042</code></li> <li><code>card_version_start_memory_address = 0x0078</code></li> <li><code>part_code_start_memory_address = 0x0080</code></li> </ul> <p>Number of bytes to read for each field:</p> <ul> <li>Card ID: 2 bytes</li> <li>Card Name: 54 bytes</li> <li>Card Version: 8 bytes</li> <li>Part Code: 64 bytes</li> <li>card_uid: 4 bytes</li> <li>EEPROM 48-bit EUI (EUI-48): 6 bytes</li> </ul> <p>Device address probing range:</p> <ul> <li><code>0x50</code> to <code>0x57</code></li> </ul> <p>Use of macros:</p> <ul> <li><code>#define SUCCESS 0</code> and <code>#define FAILURE -1</code> for status returns</li> <li><code>#define M24AA256UID_UID_MEMORY_ADDRESS 0x7FFC</code></li> <li><code>#define M24AA256UID_EUI48_MEMORY_ADDRESS 0x7F7A</code></li> <li><code>IS_SPRINTF_RETURNED_ERROR()</code> for validating <code>sprintf</code> results</li> </ul>"}]}