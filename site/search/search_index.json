{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Properties Get Curiosity Eeprom Card ID Retrieving EEPROM Card Details","title":"Home"},{"location":"#properties","text":"","title":"Properties"},{"location":"#get-curiosity-eeprom-card-id","text":"","title":"Get Curiosity Eeprom Card ID"},{"location":"#retrieving-eeprom-card-details","text":"","title":"Retrieving EEPROM Card Details"},{"location":"Get_curiosityEepromCardID/","text":"\ud83c\udff7\ufe0f Title: Card ID Retrieval for Curiosity Card \ud83c\udd94 Story ID: CUR-132 \ud83d\udc64 Author: Narasapuram Yaswanth \ud83d\uddd3\ufe0f Date: 17-06-2025 \ud83d\udd0d 1. Overview This feature enables retrieval of the unique Card ID from the Curiosity card. This ID is used by the Galaxy application to fetch corresponding card metadata. \ud83d\udce6 2. Scope This feature focuses exclusively on the retrieval of the Card ID for a Curiosity Card. While the Card ID is expected to be stored in the EEPROM, in the current Erlang implementation, it is fetched from an environment variable. The Card ID acts as a critical identifier that enables Galaxy applications to link and retrieve relevant card metadata. \u2705 In Scope Reading the 2-byte Card ID from EEPROM using the I2C protocol (In Brief). Defining and exposing a new Erlang property curiosityEepromCardID that reads the Card ID from environment variables. Handling valid inputs structured as [?INDEX_TUPLE, ?INTERFACE_TUPLE] and returning appropriate output format. Implementing input validation and error responses for incorrect or malformed requests. \ud83d\udd01 3. Inputs and Outputs \ud83d\udce5 Inputs: Input to get_curiosityEepromCardID property is list of two tuples: [ ?INDEX_TUPLE, ?INTERFACE_TUPLE ] ?INDEX_TUPLE -> {index,[ {node,_Node_number}, {rack, _Rack}, {subrack, _Subrack}, {slot, _Slot} ]} ?INTERFACE_TUPLE -> { interface, List_of_interfaces } \ud83d\udce4 Outputs: Card ID is 2-byte hexadecimal. On success the output looks like: [ { success }, [ { Property_name , Card_id_from_eeprom } ] ] Property_name -> curiosityEepromCardID and Card_id_from_eeprom -> 0x5C \ud83d\udee0\ufe0f 4. Design Approach To enable the Erlang node to access card-related information during system initialization, the card ID is first retrieved from EEPROM at the C layer and made available to the Galaxy application through environment variables present in the vim.args file. Details: Added function: get_curiosityEepromCardID() in curiosity_mif.erl module. This function calls ?COMMON_FUNCTION_LIB:read_environment_variable_value(card_id_from_eeprom) to fetch the Card ID from the environment variables using the card_id_from_eeprom atom. The returned value is stored in the Card_id_from_eeprom variable and is used for further validation or processing logic as needed by the application. Note: If you want a clear explanation of how the card-related information is stored in the EEPROM, go to.. Retrieving_EEPROM_Card_details \ud83d\udd04 5. Sequence Flow for get_curiosityEepromCardId/1 Input: The function is called with a single argument which is a tuple of the form [ ?INDEX_TUPLE, ?INTERFACE_TUPLE ] Property Assignment: The variable Property_name is assigned the atom curiosityEepromCardId . Pattern Matching on ?INTERFACE_TUPLE : The function matches the value of ?INTERFACE_TUPLE : If it matches { interface, [0] } : Calls ?COMMON_FUNCTION_LIB:read_environment_variable_value(card_id_from_eeprom) to get Card_id_from_eeprom . Otherwise, if it matches { interface, _any } (anything other than [0] ): Logs an \"Invalid Argument\" error and returns an error tuple. Check if Card_id_from_eeprom is an integer: If Card_id_from_eeprom is an integer : Return [ { success }, [ { curiosityEepromCardId, Card_id_from_eeprom } ] ] If not an integer : Prints an error indicating the environment variable is not an integer and returns, [ { error, card_id_from_environment_variable_is_not_an_integer_value }, [ ] ] If the initial argument does not match the expected tuple structure: prints an \"Invalid Argument\" error and returns, [ { error, invalid_argument }, [ ] ] \ud83d\udea8 6. Error Handling Failure Scenarios in Erlang: If invalid arguments are passed to get_card_details_from_eeprom() , an error message is printed and the function returns: [ { error, invalid_argument }, [ ] ] If ?INTERFACE_TUPLE is not {interface, [0]} , an error message is printed and the function returns: [ { error, invalid_argument }, [ ] ] If the return value from ?COMMON_FUNCTION_LIB:read_environment_variable_value(card_id_from_eeprom) is not an integer, an error message is printed and the function returns: [ { error, card_id_from_environment_variable_is_not_an_integer_value }, [ ] ] \u2699\ufe0f 7. Configuration or Constants -define CURIOSITY_EEPROM_CARD_ID 92 -define CURIOSITY_I2C_BUS_0 0 -define CURIOSITY_I2C_BUS_1 1 -define COMMON_FUNCTION_LIB galaxy_common_function \ud83d\udcc2 8. Impacted Files Modified: start_uo.c Added: This property is added in curiosity_mif.erl \ud83e\uddea 9. Unit Test Summary Acceptance Test Cases: CUR-1 Retrieve EEPROM Card ID with valid interface number. CUR-2 Retrieve EEPROM Card ID with valid interface number. \ud83d\udd17 10. References Jira Story CUR-132\u200b Commit: a1b2c3d - card_id: add support for ID retrieval\u200b I2C Protocol Ref Sheet\u200b","title":"Get curiosityEepromCardID"},{"location":"Get_curiosityEepromCardID/#title-card-id-retrieval-for-curiosity-card","text":"\ud83c\udd94 Story ID: CUR-132 \ud83d\udc64 Author: Narasapuram Yaswanth \ud83d\uddd3\ufe0f Date: 17-06-2025","title":"\ud83c\udff7\ufe0f Title: Card ID Retrieval for Curiosity Card"},{"location":"Get_curiosityEepromCardID/#1-overview","text":"This feature enables retrieval of the unique Card ID from the Curiosity card. This ID is used by the Galaxy application to fetch corresponding card metadata.","title":"\ud83d\udd0d 1. Overview"},{"location":"Get_curiosityEepromCardID/#2-scope","text":"This feature focuses exclusively on the retrieval of the Card ID for a Curiosity Card. While the Card ID is expected to be stored in the EEPROM, in the current Erlang implementation, it is fetched from an environment variable. The Card ID acts as a critical identifier that enables Galaxy applications to link and retrieve relevant card metadata. \u2705 In Scope Reading the 2-byte Card ID from EEPROM using the I2C protocol (In Brief). Defining and exposing a new Erlang property curiosityEepromCardID that reads the Card ID from environment variables. Handling valid inputs structured as [?INDEX_TUPLE, ?INTERFACE_TUPLE] and returning appropriate output format. Implementing input validation and error responses for incorrect or malformed requests.","title":"\ud83d\udce6 2. Scope"},{"location":"Get_curiosityEepromCardID/#3-inputs-and-outputs","text":"\ud83d\udce5 Inputs: Input to get_curiosityEepromCardID property is list of two tuples: [ ?INDEX_TUPLE, ?INTERFACE_TUPLE ] ?INDEX_TUPLE -> {index,[ {node,_Node_number}, {rack, _Rack}, {subrack, _Subrack}, {slot, _Slot} ]} ?INTERFACE_TUPLE -> { interface, List_of_interfaces } \ud83d\udce4 Outputs: Card ID is 2-byte hexadecimal. On success the output looks like: [ { success }, [ { Property_name , Card_id_from_eeprom } ] ] Property_name -> curiosityEepromCardID and Card_id_from_eeprom -> 0x5C","title":"\ud83d\udd01 3. Inputs and Outputs"},{"location":"Get_curiosityEepromCardID/#4-design-approach","text":"To enable the Erlang node to access card-related information during system initialization, the card ID is first retrieved from EEPROM at the C layer and made available to the Galaxy application through environment variables present in the vim.args file. Details: Added function: get_curiosityEepromCardID() in curiosity_mif.erl module. This function calls ?COMMON_FUNCTION_LIB:read_environment_variable_value(card_id_from_eeprom) to fetch the Card ID from the environment variables using the card_id_from_eeprom atom. The returned value is stored in the Card_id_from_eeprom variable and is used for further validation or processing logic as needed by the application. Note: If you want a clear explanation of how the card-related information is stored in the EEPROM, go to.. Retrieving_EEPROM_Card_details","title":"\ud83d\udee0\ufe0f 4. Design Approach"},{"location":"Get_curiosityEepromCardID/#5-sequence-flow-for-get_curiosityeepromcardid1","text":"Input: The function is called with a single argument which is a tuple of the form [ ?INDEX_TUPLE, ?INTERFACE_TUPLE ] Property Assignment: The variable Property_name is assigned the atom curiosityEepromCardId . Pattern Matching on ?INTERFACE_TUPLE : The function matches the value of ?INTERFACE_TUPLE : If it matches { interface, [0] } : Calls ?COMMON_FUNCTION_LIB:read_environment_variable_value(card_id_from_eeprom) to get Card_id_from_eeprom . Otherwise, if it matches { interface, _any } (anything other than [0] ): Logs an \"Invalid Argument\" error and returns an error tuple. Check if Card_id_from_eeprom is an integer: If Card_id_from_eeprom is an integer : Return [ { success }, [ { curiosityEepromCardId, Card_id_from_eeprom } ] ] If not an integer : Prints an error indicating the environment variable is not an integer and returns, [ { error, card_id_from_environment_variable_is_not_an_integer_value }, [ ] ] If the initial argument does not match the expected tuple structure: prints an \"Invalid Argument\" error and returns, [ { error, invalid_argument }, [ ] ]","title":"\ud83d\udd04 5. Sequence Flow for get_curiosityEepromCardId/1"},{"location":"Get_curiosityEepromCardID/#6-error-handling","text":"Failure Scenarios in Erlang: If invalid arguments are passed to get_card_details_from_eeprom() , an error message is printed and the function returns: [ { error, invalid_argument }, [ ] ] If ?INTERFACE_TUPLE is not {interface, [0]} , an error message is printed and the function returns: [ { error, invalid_argument }, [ ] ] If the return value from ?COMMON_FUNCTION_LIB:read_environment_variable_value(card_id_from_eeprom) is not an integer, an error message is printed and the function returns: [ { error, card_id_from_environment_variable_is_not_an_integer_value }, [ ] ]","title":"\ud83d\udea8 6. Error Handling"},{"location":"Get_curiosityEepromCardID/#7-configuration-or-constants","text":"-define CURIOSITY_EEPROM_CARD_ID 92 -define CURIOSITY_I2C_BUS_0 0 -define CURIOSITY_I2C_BUS_1 1 -define COMMON_FUNCTION_LIB galaxy_common_function","title":"\u2699\ufe0f 7. Configuration or Constants"},{"location":"Get_curiosityEepromCardID/#8-impacted-files","text":"Modified: start_uo.c Added: This property is added in curiosity_mif.erl","title":"\ud83d\udcc2 8. Impacted Files"},{"location":"Get_curiosityEepromCardID/#9-unit-test-summary","text":"","title":"\ud83e\uddea 9. Unit Test Summary"},{"location":"Get_curiosityEepromCardID/#acceptance-test-cases","text":"CUR-1 Retrieve EEPROM Card ID with valid interface number. CUR-2 Retrieve EEPROM Card ID with valid interface number.","title":"Acceptance Test Cases:"},{"location":"Get_curiosityEepromCardID/#10-references","text":"Jira Story CUR-132\u200b Commit: a1b2c3d - card_id: add support for ID retrieval\u200b I2C Protocol Ref Sheet\u200b","title":"\ud83d\udd17 10. References"},{"location":"Getting_Card_Details_From_EEPROM/","text":"\ud83d\udcc4 Getting Card Deatils From EEPROM \ud83c\udff7\ufe0f Title: Card Details Retrieval for Curiosity from EEPROM \ud83d\udc64 Author: Narasapuram Yaswanth \ud83d\uddd3\ufe0f Date: 19-06-2025 \ud83d\udd0d 1. Overview This feature enables retrieval of the Card details from EEPROM for Curiosity card. The retrieved information will be used by the Galaxy application. \ud83d\udce6 2. Scope This feature focuses on the retrieval of card data stored in the EEPROM of a Curiosity Card. The retrieved information is essential for Galaxy applications to link and access relevant metadata associated with the card. \ud83d\udd01 3. Inputs and Outputs \ud83d\udce5 Inputs: Input to get_card_details_from_eeprom() function is : &card_details_from_eeprom_return which is a structure variable struct card_details_from_eeprom { unsigned short card_id; char card_name[55]; char part_code[65]; char internal_hardware_version[8]; char internal_software_version[8]; char external_hardware_version[8]; char external_software_version[8]; unsigned int card_uid; char mac_compatible_48_bit_uid[20]; unsigned char m24aa256uid_device_address; }; \ud83d\udce4 Outputs: The function get_card_details_from_eeprom() returns a status code: SUCCESS (typically defined as 0) if all EEPROM reads and data formatting operations succeed. FAILURE (typically defined as -1) if any error occurs during EEPROM probing, reading, or data formatting. \ud83d\udee0\ufe0f 4. Design Approach The start_up.c file retrieves card-related information from EEPROM using the get_card_details_from_eeprom() function, which reads multiple fields from an EEPROM device connected via I2C_BUS_0, and stores the information in the vm.args file. Details: It first probes the EEPROM device address using a shell command ( i2cdetect ) executed via system() . The exit code stored in eeprom_probe_status . The detected address is then stored in command_error_code using WEXITSTATUS(eeprom_probe_status) . Several blocks of memory are read from the EEPROM using read_multiple_bytes_from_m24aa256uid() : Card ID (2 bytes) Card Name (54 bytes) Part Code (64 bytes) Card Version (8 bytes) Versions are formatted into string representations of major.minor versions for internal/external hardware/software. The function reads a 4-byte UID and a 6-byte 48-bit unique identification number (EUI-48) for MAC compatibility. EUI-48 is validated to be non-zero to confirm a valid EEPROM. The MAC address is formatted into a standard colon-separated hex string. Any failure during I2C read or formatting causes the function to return FAILURE . \ud83d\udd04 5. Step-wise Flow System Initialization Flow: 1. Triggered from system initialization. 2. Executes start_up.c . 3. Insdie start_up.c , it calls get_card_details_from_eeprom() . Inside get_card_details_from_eeprom() Function: 4. Execute shell command to probe EEPROM I2C device address. 5. Validate device address. 6. Then call to read_multiple_bytes_from_m24aa256uid() to: - Read card ID bytes from EEPROM. - Read card name bytes from EEPROM. - Read part code bytes from EEPROM. - Read card version bytes from EEPROM. 7. Format version numbers into strings. 8. Then call to read_uid_from_m24aa256uid() to: - Read card UID bytes from EEPROM. 9. Then call to read_eui48_from_m24aa256uid() to: - Read 48-bit EUI-48 bytes from EEPROM. 10. Validate EUI-48 is non-zero. 11. Format MAC-compatible 48-bit UID string. 12. Return SUCCESS if all operations succeed; otherwise FAILURE . \ud83d\udea8 6. Error Handling If the EEPROM probe command fails or returns an invalid address, it prints an error message to the console and return FAILURE . If any of the EEPROM reads fail, the function returns FAILURE . If formatting the version strings or MAC string fails (e.g., sprintf returns an error), it prints an error message to the console and return FAILURE . If the EUI-48 read value is all zeros, indicating invalid data, prints an error message to the console and return FAILURE . These errors ensure the system does not operate on invalid or incomplete card data. \u2699\ufe0f 7. Configuration or Constants EEPROM memory address constants: card_id_start_memory_address = 0x0040 card_name_start_memory_address = 0x0042 card_version_start_memory_address = 0x0078 part_code_start_memory_address = 0x0080 Number of bytes to read for each field: Card ID: 2 bytes Card Name: 54 bytes Card Version: 8 bytes Part Code: 64 bytes card_uid: 4 bytes EEPROM 48-bit EUI (EUI-48): 6 bytes Device address probing range: 0x50 to 0x57 Use of macros: #define SUCCESS 0 and #define FAILURE -1 for status returns #define M24AA256UID_UID_MEMORY_ADDRESS 0x7FFC #define M24AA256UID_EUI48_MEMORY_ADDRESS 0x7F7A IS_SPRINTF_RETURNED_ERROR() for validating sprintf results","title":"\ud83d\udcc4 Getting Card Deatils From EEPROM"},{"location":"Getting_Card_Details_From_EEPROM/#getting-card-deatils-from-eeprom","text":"\ud83c\udff7\ufe0f Title: Card Details Retrieval for Curiosity from EEPROM \ud83d\udc64 Author: Narasapuram Yaswanth \ud83d\uddd3\ufe0f Date: 19-06-2025","title":"\ud83d\udcc4 Getting Card Deatils From EEPROM"},{"location":"Getting_Card_Details_From_EEPROM/#1-overview","text":"This feature enables retrieval of the Card details from EEPROM for Curiosity card. The retrieved information will be used by the Galaxy application.","title":"\ud83d\udd0d 1. Overview"},{"location":"Getting_Card_Details_From_EEPROM/#2-scope","text":"This feature focuses on the retrieval of card data stored in the EEPROM of a Curiosity Card. The retrieved information is essential for Galaxy applications to link and access relevant metadata associated with the card.","title":"\ud83d\udce6 2. Scope"},{"location":"Getting_Card_Details_From_EEPROM/#3-inputs-and-outputs","text":"\ud83d\udce5 Inputs: Input to get_card_details_from_eeprom() function is : &card_details_from_eeprom_return which is a structure variable struct card_details_from_eeprom { unsigned short card_id; char card_name[55]; char part_code[65]; char internal_hardware_version[8]; char internal_software_version[8]; char external_hardware_version[8]; char external_software_version[8]; unsigned int card_uid; char mac_compatible_48_bit_uid[20]; unsigned char m24aa256uid_device_address; }; \ud83d\udce4 Outputs: The function get_card_details_from_eeprom() returns a status code: SUCCESS (typically defined as 0) if all EEPROM reads and data formatting operations succeed. FAILURE (typically defined as -1) if any error occurs during EEPROM probing, reading, or data formatting.","title":"\ud83d\udd01 3. Inputs and Outputs"},{"location":"Getting_Card_Details_From_EEPROM/#4-design-approach","text":"The start_up.c file retrieves card-related information from EEPROM using the get_card_details_from_eeprom() function, which reads multiple fields from an EEPROM device connected via I2C_BUS_0, and stores the information in the vm.args file. Details: It first probes the EEPROM device address using a shell command ( i2cdetect ) executed via system() . The exit code stored in eeprom_probe_status . The detected address is then stored in command_error_code using WEXITSTATUS(eeprom_probe_status) . Several blocks of memory are read from the EEPROM using read_multiple_bytes_from_m24aa256uid() : Card ID (2 bytes) Card Name (54 bytes) Part Code (64 bytes) Card Version (8 bytes) Versions are formatted into string representations of major.minor versions for internal/external hardware/software. The function reads a 4-byte UID and a 6-byte 48-bit unique identification number (EUI-48) for MAC compatibility. EUI-48 is validated to be non-zero to confirm a valid EEPROM. The MAC address is formatted into a standard colon-separated hex string. Any failure during I2C read or formatting causes the function to return FAILURE .","title":"\ud83d\udee0\ufe0f 4. Design Approach"},{"location":"Getting_Card_Details_From_EEPROM/#5-step-wise-flow","text":"System Initialization Flow: 1. Triggered from system initialization. 2. Executes start_up.c . 3. Insdie start_up.c , it calls get_card_details_from_eeprom() . Inside get_card_details_from_eeprom() Function: 4. Execute shell command to probe EEPROM I2C device address. 5. Validate device address. 6. Then call to read_multiple_bytes_from_m24aa256uid() to: - Read card ID bytes from EEPROM. - Read card name bytes from EEPROM. - Read part code bytes from EEPROM. - Read card version bytes from EEPROM. 7. Format version numbers into strings. 8. Then call to read_uid_from_m24aa256uid() to: - Read card UID bytes from EEPROM. 9. Then call to read_eui48_from_m24aa256uid() to: - Read 48-bit EUI-48 bytes from EEPROM. 10. Validate EUI-48 is non-zero. 11. Format MAC-compatible 48-bit UID string. 12. Return SUCCESS if all operations succeed; otherwise FAILURE .","title":"\ud83d\udd04 5. Step-wise Flow"},{"location":"Getting_Card_Details_From_EEPROM/#6-error-handling","text":"If the EEPROM probe command fails or returns an invalid address, it prints an error message to the console and return FAILURE . If any of the EEPROM reads fail, the function returns FAILURE . If formatting the version strings or MAC string fails (e.g., sprintf returns an error), it prints an error message to the console and return FAILURE . If the EUI-48 read value is all zeros, indicating invalid data, prints an error message to the console and return FAILURE . These errors ensure the system does not operate on invalid or incomplete card data.","title":"\ud83d\udea8 6. Error Handling"},{"location":"Getting_Card_Details_From_EEPROM/#7-configuration-or-constants","text":"EEPROM memory address constants: card_id_start_memory_address = 0x0040 card_name_start_memory_address = 0x0042 card_version_start_memory_address = 0x0078 part_code_start_memory_address = 0x0080 Number of bytes to read for each field: Card ID: 2 bytes Card Name: 54 bytes Card Version: 8 bytes Part Code: 64 bytes card_uid: 4 bytes EEPROM 48-bit EUI (EUI-48): 6 bytes Device address probing range: 0x50 to 0x57 Use of macros: #define SUCCESS 0 and #define FAILURE -1 for status returns #define M24AA256UID_UID_MEMORY_ADDRESS 0x7FFC #define M24AA256UID_EUI48_MEMORY_ADDRESS 0x7F7A IS_SPRINTF_RETURNED_ERROR() for validating sprintf results","title":"\u2699\ufe0f 7. Configuration or Constants"}]}